function gadget:GetInfo()
    return {
        name    = "Pieces Apply",
        desc    = "Use pieces of one unit to another, dynamically and pretty",
        author  = "XNTEABDSC, inspired by Pressure Lines's unit_changepiece.lua",
        date    = "",
        license = "GNU GPL, v2 or later",
        layer   = 50,
        enabled = true --loaded by default?
    }
end


local Pieces=GG.Pieces or {}
GG.Pieces=Pieces

local jsonencode=Spring.Utilities.json.encode
local jsondecode=Spring.Utilities.json.decode

if (gadgetHandler:IsSyncedCode()) then
    ---@type {[string]:boolean}
    local DynPieceInfos={}
    
    ---@class DynPieceInfo
    ---@field name string?
    ---@field basePiece string|integer
    ---@field parent integer|string|nil
    ---@field matrix {[integer]:number}?
    ---@field matrix2 {[integer]:number}?
    ---@field drawPieces { [integer]: {piece:(integer|string),matrix:{[integer]:number}?,matrix2:{[integer]:number}?} }

    ---@class DynPiecesInfo
    ---@field unitDefId UnitDefId
    ---@field infos {[integer]:DynPieceInfo}

    local TryLoadUnitPiecesInfos=GG.Pieces.LoadUnitPiecesInfos

    function gadget:Initialize()
        TryLoadUnitPiecesInfos=GG.Pieces.LoadUnitPiecesInfos
    end

    ---@param dynPieceInfo DynPiecesInfo
    local function CreateDynPieceInfo(name,dynPieceInfo)
        if DynPieceInfos[name] then return end
        TryLoadUnitPiecesInfos(dynPieceInfo.unitDefId)
        SendToUnsynced("CreateDynPieceInfo",name,jsonencode(dynPieceInfo))
        DynPieceInfos[name]=true
    end
    Pieces.CreateDynPieceInfo=CreateDynPieceInfo
    local function ApplyDynPieceInfoNamed(unitId,tarPieceToSrcPieceInfo,srcPiecesInfoName)
        SendToUnsynced("ApplyDynPieceInfoNamed",unitId,jsonencode(tarPieceToSrcPieceInfo),srcPiecesInfoName)
    end
    Pieces.ApplyDynPieceInfoNamed=ApplyDynPieceInfoNamed
else
    
    ---@class DynPieceInfoProcessed
    ---@field basePieceId integer
    ---@field parent integer?
    ---@field matrix {[integer]:number}?
    ---@field matrix2 {[integer]:number}?
    ---@field drawList integer
    
    ---@class DynPiecesInfoProcessed
    ---@field infos {[integer]:DynPieceInfoProcessed}

    ---@type {[string]:DynPieceInfoProcessed}
    local DynPieceInfos={}


    local wacky_utils = Spring.Utilities.wacky_utils
    local MultMatrix44 = wacky_utils.MultMatrix44
    local NewMatrix44Unit = wacky_utils.NewMatrix44Unit()


    local glCreateList = gl.CreateList
    local glPushMatrix = gl.PushMatrix
    local glPopMatrix = gl.PopMatrix
    local glLoadMatrix = gl.LoadMatrix
    local glCallList = gl.CallList



    ---@param Infos DynPiecesInfo
    ---@return DynPiecesInfoProcessed
    local function ProcessDynPiecesInfo(Infos)
        local infos={}
        local unitDefId=Infos.unitDefId
        local unitPieces = Pieces.UnitsPieces[unitDefId]
        local unitPiecesMap = Pieces.UnitsPiecesMap[unitDefId]
        local unitPieceInfos = Pieces.UnitsPieceInfos[unitDefId]
        local unitPiecesMatrix = Pieces.UnitsPiecesMatrix[unitDefId]
        local unitPiecesParent = Pieces.UnitsPiecesParent[unitDefId]
        local unitPieceDrawLists = Pieces.UnitsPieceDrawLists[unitDefId]
        ---@return {[integer]:number}
        local function GetMatrixFromAToB(a, b)
            local Matrix = NewMatrix44Unit() --UnitPiecesMatrix[a]
            local cur = a
            while (cur ~= nil and cur ~= b) do
                local Matrix2 = unitPiecesMatrix[cur]
                Matrix = MultMatrix44(Matrix, Matrix2)
                cur = unitPiecesParent[cur]
            end
            if cur == nil then
                Spring.Echo("unit_piece_apply: piece " ..
                tostring(unitPieces[a]) .. " dont have parent " .. tostring(unitPieces[b]))
            end
            return Matrix
        end
        local pieceId2PieceInfo = {}

        ---commented
        ---@param info DynPieceInfo
        ---@param i integer
        local function ProcessDynPieceInfo(i,info)
            local basePieceId = info.basePiece
            if type(basePieceId) == "string" then
                basePieceId = unitPiecesMap[basePieceId]
            end
            pieceId2PieceInfo[basePieceId] = i
            local UnitPieceInfo = unitPieceInfos[basePieceId]

            local ParentNode = info.parent

            if ParentNode == nil then
                local cur = basePieceId
                while (cur ~= nil) do
                    local curPieceInfo = pieceId2PieceInfo[cur]
                    if curPieceInfo then
                        ParentNode = curPieceInfo
                        break
                    end
                    cur = unitPiecesParent[cur]
                end
            end

            local Matrix = info.matrix
            if not Matrix then
                if ParentNode then
                    local ParentPiece = o[ParentNode].BasePiece
                    Matrix = GetMatrixFromAToB(basePieceId, ParentPiece)
                end
            end
            -- ---@cast Matrix -unknown|nil
            local Matrix2 = info.matrix2
            --[=[
        if Matrix2 then
            Matrix=MultMatrix44(Matrix2,Matrix)
        end]=]
            local DrawPieces = info.drawPieces
            local DList = glCreateList(function()
                for _, p in pairs(DrawPieces) do
                    local pidx = p.piece
                    if type(pidx) == "string" then
                        pidx = unitPiecesMap[pidx]
                    end
                    local pMatrix = p.matrix
                    if not pMatrix then
                        pMatrix = GetMatrixFromAToB(pidx, basePieceId)
                    end
                    local pMatrix2 = p.matrix2
                    if pMatrix2 then
                        pMatrix = MultMatrix44(pMatrix2, pMatrix)
                    end
                    glPushMatrix()
                    glLoadMatrix(pMatrix)
                    glCallList(unitPieceDrawLists[pidx])
                    glPopMatrix()
                end
            end)
            ---@type DynPieceInfoProcessed
            local o2 = {
                basePieceId = basePieceId,
                parent = ParentNode,
                matrix = Matrix,
                matrix2 = Matrix2,
                drawList = DList,
            }
            o[i] = o2
            
        end

        for i, v in pairs(Infos.infos) do
            ProcessDynPieceInfo(i,v)
        end

        return {
            infos=infos
        }
    end

    Pieces.DynPieceInfo = ProcessDynPiecesInfo


    local SetupRendering
    do
        local surSetLODCount = Spring.UnitRendering.SetLODCount
        local surSetLODLength = Spring.UnitRendering.SetLODLength
        local surSetMaterial = Spring.UnitRendering.SetMaterial
        SetupRendering = function(unitID, unitDefID)
            --- why?
            surSetLODCount(unitID, 1)
            surSetLODLength(unitID, 1, -1000)
            -- ]=]
            -- [=[
            surSetMaterial(unitID, 1, "opaque",
                { shader = "s3o", texunit0 = '%' .. unitDefID .. ":0", texunit1 = '%' .. unitDefID .. ":1" })
            surSetMaterial(unitID, 1, "shadow", { shader = "s3o" })
            surSetMaterial(unitID, 1, "alpha", { shader = "s3o" })
        end
    end
    Pieces.SetupRendering=SetupRendering

    local spGetUnitPieceList = Spring.GetUnitPieceList
    local spGetUnitPieceMap = Spring.GetUnitPieceMap
    local spSetUnitPieceMatrix = Spring.SetUnitPieceMatrix
    local spSetUnitPieceParent = Spring.SetUnitPieceParent
    local spGetUnitPieceMatrix = Spring.GetUnitPieceMatrix
    local surSetPieceList = Spring.UnitRendering.SetPieceList

    local spGetUnitDefID = Spring.GetUnitDefID
    ---@param tarPieceToSrcPieceInfo {[integer|string]:integer}
    ---@param srcPiecesInfo {[integer]:DynPieceInfoProcessed}
    local function ApplyDynPieceInfo(unitId, tarPieceToSrcPieceInfo, srcPiecesInfo)
        local pieceList = spGetUnitPieceList(unitId)
        local pieceMap = spGetUnitPieceMap(unitId)
        ---@cast pieceMap -nil

        SetupRendering(unitId, spGetUnitDefID(unitId))

        local srcPieceInfoToTarPiece = {}
        for k, v in pairs(tarPieceToSrcPieceInfo) do
            if type(v) == "string" then
                v = pieceMap[v]
                tarPieceToSrcPieceInfo[k] = v
            end
            srcPieceInfoToTarPiece[v] = k
        end
        ---@cast tarPieceToSrcPieceInfo {[integer]:integer}

        for tarPieceId, srcPieceInfoId in pairs(tarPieceToSrcPieceInfo) do
            local srcPieceInfo = srcPiecesInfo[srcPieceInfoId]
            local srcParent = srcPieceInfo.parent
            if srcParent then
                local srcParentTar = srcPieceInfoToTarPiece[srcParent]
                if srcParentTar then
                    spSetUnitPieceParent(unitId, tarPieceId, srcParentTar)
                end
            end
            local Matrix = srcPieceInfo.matrix or { spGetUnitPieceMatrix(unitId) }
            local Matrix2 = srcPieceInfo.matrix2
            if Matrix2 then
                Matrix = MultMatrix44(Matrix2, Matrix)
            end
            spSetUnitPieceMatrix(unitId, tarPieceId, Matrix)
            local DList = srcPieceInfo.drawList
            surSetPieceList(unitID, 1, tarPieceId, DList)
        end
    end

    Pieces.ApplyDynPieceInfo = ApplyDynPieceInfo


    function gadget:Initialize()
        gadgetHandler:AddSyncAction("CreateDynPieceInfo",function(msg,name,dynPieceInfo)
            --ProcessDynPieceInfo
            DynPieceInfos[name]=ProcessDynPiecesInfo(jsondecode(dynPieceInfo))
        end)
        gadgetHandler:AddSyncAction("ApplyDynPieceInfoNamed",function(msg,unitId,tarPieceToSrcPieceInfo,srcPiecesInfoName)
            ApplyDynPieceInfo(unitId,jsondecode(tarPieceToSrcPieceInfo),DynPieceInfos[srcPiecesInfoName])
        end)
    end
end
